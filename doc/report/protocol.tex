\section{Communication Protocol}
\label{ref:protocol}

\subsection{Description}
The communication protocol is the same for both the client-server and client-client 
communications. 
It has been adapted from TLS 1.3 (RFC 8446\footnote{\url{https://tools.ietf.org/html/rfc8446}}).
The choice of this adaptation is due to the fact that the requested specifications 
closely match the features of TLS (e.g. perfect forward secrecy, authentication, 
message integrity, etc.).

The communication protocol is split in two parts:
\begin{itemize}
    \item \textbf{handshake protocol}: establishes a shared key among the two 
        parties.
    \item \textbf{record protocol}: sends an encrypted message to the other 
        party.
\end{itemize} 

\subsubsection{Handshake Protocol}
The differences of the proposed handshake protocol from TLS 1.3 handshake protocol
using ECDH are the following:
\begin{itemize}
    \item \textbf{No cipher suite negotiation} since we are going to always use 
        the same algorithms.
    \item \textbf{No certificate exchange}: certificates are exchanged before the 
        connection (either by explicitly asking for it, e.g. client connecting to
        the server, or from a previous knowledge, e.g. clients receiving the 
        peer certificate from the server at the start of the game).
    \item \textbf{certificate verification and finished messages are collapsed in the same 
        message}: it would have been redundant to send both HMAC and DS. 
        Furthermore, the DS is computed on just the key parameters (ephemeral 
        public keys, nonces and identities) instead of the whole communication
        transcript.
\end{itemize}

\begin{figure}[h!]
    \centering
    \small
    \begin{sequencediagram}
        \newinst{A}{A}{}
        \newinst[7]{B}{B}{}

        \begin{callself}{A}{Generate random nonce and ephemeral public key}{$N_A,K^E_A$}\end{callself}
        \mess{A}{CLIENT HELLO: $A,B,N_A,K^E_A$}{B}

        \begin{callself}{B}{Generate nonce and ephemeral public key}{$N_B,K^E_B$}\end{callself}
        \begin{callself}{B}{Compute digital signature}{$S_B = DS_B(A,B,N_A,K^E_A,N_B,K^E_B)$}\end{callself}
        \mess{B}{SERVER HELLO: $B,A,N_B,K^E_B,S_B$}{A}

        \begin{callself}{A}{Verify signature $S_B$}{True/False}\end{callself}
        \begin{callself}{A}{Compute digital signature}{$S_A = DS_A(A,B,N_A,K^E_A,N_B,K^E_B)$}\end{callself}
        \mess{A}{CLIENT VERIFY: $S_A$}{B}
        \begin{callself}{B}{Verify signature $S_A$}{True/False}\end{callself}
    \end{sequencediagram}
    \caption{Sequence diagram of the handshake protocol. $A$ and $B$ are the 
        identities of the two parties, $N_A$ and $N_B$ are random nonces,
        $K^E_A$ and $K^E_B$ are ECDH ephemeral public keys, 
        $K_A$ and $K_B$ are the parties' public keys,
        $S_A$ and $S_B$ are the digital signatures.}
    \label{fig:seqdiag}
\end{figure}

Here are the steps that the parties A and B need to perform, shown also in figure
\ref{fig:seqdiag}:
\begin{enumerate}
    \item \textbf{A generates} her random nonce $N_A$ and her ECDH ephemeral public key $K^E_A$.
    \item \textbf{A sends to B} her identifier $A$, B's identifier $B$, $N_A$ and $K^E_A$.
    \item \textbf{B generates} his random nonce $N_B$ and his ECDH ephemeral public key $K^E_B$.
    \item \textbf{B computes} the digital signature using his private key $K_B$ over the plaintext:
    \begin{equation*}
            (A,B,N_A,K^E_A,N_B,K^E_B)
    \end{equation*}
    \item \textbf{B sends to A} his identifier $B$, A's identifier $A$, $N_B$, $K^E_B$ and his digital signature $S_B$.
    \item \textbf{A verifies} B's signature.
    \item \textbf{A computes} the digital signature using her private key $K_A$ over the same plaintext as B did.
    \item \textbf{A sends to B} the digital signature.
    \item \textbf{B verifies} A's signature.
\end{enumerate}

When the handshake completes, both parties can generate the shared secrets 
using the key derivation function \emph{HKDF}:
\begin{itemize}
    \item \emph{client write key}
    \item \emph{client write IV}
    \item \emph{server write key}
    \item \emph{server write IV}
\end{itemize}

Furthermore, both parties initialize two 64 bit counters to 0, which will 
represent the sequence number of the client and server messages. These sequence
numbers are not sent over the network but are updated at any new received
message.

\subsubsection{Record Protocol}
If A wants to send a message to B she needs to:
\begin{enumerate}
    \item build the message to send.
    \item encrypt the message using AES-128 in GCM using the length of the 
        message and the byte 0 (the type of the record message) as AAD. The IV
        is the IV generated by the \emph{HKDF}, where the first 64 bits are 
        XOR-ed with the 64-bit sequence number.
    \item build the new message as length, 0 (message type), AES-GCM tag, 
        ciphertext.
    \item send the message.
    \item increase the write sequence number.
\end{enumerate}

If B wants to receive a message from A he needs to:
\begin{enumerate}
    \item receive the full message.
    \item decrypt the message following the same instructions as before.
    \item check the tag
    \item increase the read sequence number.
\end{enumerate}

\subsection{BAN-logic proof}
\subsubsection{Real protocol}
From the description before, the formal specification of the protocol easily 
follows as presented below.
\begin{align*}
    &M1 \; A \rightarrow B : A, B, N_A, K_A^E \\
    &M2 \; B \rightarrow A : B, A, N_B, K_B^E, \{h(A,B,N_A,N_B,K_A^E,K_B^E)\}_{k_B^{-1}} \\
    &M3 \; A \rightarrow B : \{h(A,B,N_A,N_B,K_A^E,K_B^E)\}_{k_A^{-1}}
\end{align*}

\subsubsection{Assumptions}
Note that since we are using certificates to authenticate A and B public keys, 
we can assume that they both know the public key of the other.
\begin{align*}
    \begin{split}
        &A \believes \pubkey{K_B} B \\
        &A \believes \fresh{\pubkey{K_A^E}A} \\
        &A \believes \fresh{N_A} \\
        &A \believes B \controls{\pubkey{K_B^E}B} \\
        &A \believes B \controls{N_B}
    \end{split}
    \begin{split}
        &B \believes \pubkey{K_A} A \\
        &B \believes \fresh{\pubkey{K_B^E}B} \\
        &B \believes \fresh{N_B} \\
        &B \believes A \controls{\pubkey{K_A^E}A} \\
        &B \believes A \controls{N_A}
    \end{split}
\end{align*}
\subsubsection{Expected Conclusions}
In the end of the protocol, we would like that they both know all parameters to 
subsequently generate the shared secrets and that they are certain that the 
other peer knows them too.
\begin{align*}
    \begin{split}
        &A \believes (N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B) \\
        &A \believes B \believes (N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B)
    \end{split}
    \begin{split}
        &B \believes (N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B) \\
        &B \believes B \believes (N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B)
    \end{split}
\end{align*}

\subsubsection{Idealized protocol}
By digitally signing all nonces and ephemeral keys, they are proving the other 
that they know them. Therefore in the idealized protocol the hash is removed 
for clarity's sake.
\begin{align*}
    &M1 \; A \rightarrow B : N_A, \pubkey{K_A^E}A \\
    &M2 \; B \rightarrow A : \{N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B\}_{k_B^{-1}} \\
    &M3 \; A \rightarrow B : \{N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B\}_{k_A^{-1}}
\end{align*}

\subsubsection{Proof}
\paragraph{After message 1} 
From the first message, B just knows SOMEONE sent him a nonce and an ephemeral public key. 
He will use these values in later exchanges but at the moment he knows nothing 
about the sender.
\begin{align*}
    M1 \; &A \rightarrow B : N_A, \pubkey{K_A^E}A & \text{B does not know anything about the sender} \\
    &B \sees (N_A,\pubkey{K_A^E}A)
\end{align*}

\paragraph{After message 2} 
From this message A is able to verify B's identity and has confirmation that B
actually knows the nonce and her ephemeral public key. A also receives B's 
nonce and ephemeral public key.
\begin{align*}
    M2 \; &B \rightarrow A : \{N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B\}_{k_B^{-1}} & \text{apply message meaning postulate} \\
    &A \believes B \oncesaid (N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B) & \text{apply nonce verification postulate}  \\
    &A \believes B \believes (N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B) & \text{furthermore, due to juristiction postulate} \\
    &A \believes (N_B,\pubkey{K_B^E}B)
\end{align*}

\paragraph{After message 3} 
From this message B is able to verify A's identity and has confirmation that A
actually knows the nonce and his ephemeral public key.
\begin{align*}
    M3 \; &A \rightarrow B : \{N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B\}_{k_A^{-1}} & \text{apply message meaning postulate} \\
    &B \believes A \oncesaid (N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B) & \text{apply nonce verification postulate}  \\
    &B \believes A \believes (N_A,N_B,\pubkey{K_A^E}A,\pubkey{K_B^E}B) & \text{furthermore, due to juristiction postulate} \\
    &B \believes (N_A,\pubkey{K_A^E}A)
\end{align*}

\subsubsection{Final remarks}
It is worthwhile to note that the nonces $N_A,N_B$ play no role in the proof of
the protocol. 
In fact, the nonce verification postulate could be applied also on the ephemeral 
public keys (since they are fresh too). 
Furthermore, the shared DH secret is guaranteed to always be different since 
both parties choose an ephemeral public key at random at every handshake.
Therefore, we could remove the random nonces from the protocol without loss of 
security. 
